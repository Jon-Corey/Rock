<template>
    <div class="grid-filter-popup-body">
        <DropDownList v-model="searchMethod"
                      inputClasses="mb-2"
                      :showBlankItem="false"
                      :items="searchTypeItems" />

        <NumberBox v-if="showFirstValue"
                   inputClasses="mb-2"
                   v-model="searchValue"
                   :placeholder="firstValuePlaceholder" />

        <NumberBox v-if="showSecondValue"
                   inputClasses="mb-2"
                   v-model="secondSearchValue"
                   placeholder="to" />
    </div>
</template>

<script setup lang="ts">
    import NumberBox from "@Obsidian/Controls/numberBox";
    import { ref, watch, computed } from "vue";
    import DropDownList from "@Obsidian/Controls/dropDownList";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { NumberFilterMethod, NumberFilterMethodDescription } from "@Obsidian/Enums/Controls/Grid/numberFilterMethod";
    import { standardFilterProps } from "@Obsidian/Core/Controls/grid";

    type NumberSearchBag = {
        method: NumberFilterMethod;

        value?: number;

        secondValue?: number;
    };

    const props = defineProps(standardFilterProps);

    const emit = defineEmits<{
        (e: "update:modelValue", value: unknown): void
    }>();

    const searchMethod = ref(NumberFilterMethod.Equals.toString());
    const searchValue = ref<number | null>(null);
    const secondSearchValue = ref<number | null>(null);

    const searchTypeItems = ref<ListItemBag[]>(Object.keys(NumberFilterMethodDescription).map(n => {
        return {
            value: n,
            text: NumberFilterMethodDescription[n]
        };
    }));

    const showFirstValue = computed((): boolean => {
        return searchMethod.value === NumberFilterMethod.Equals.toString()
            || searchMethod.value === NumberFilterMethod.DoesNotEqual.toString()
            || searchMethod.value === NumberFilterMethod.GreaterThan.toString()
            || searchMethod.value === NumberFilterMethod.GreaterThanOrEqual.toString()
            || searchMethod.value === NumberFilterMethod.LessThan.toString()
            || searchMethod.value === NumberFilterMethod.LessThanOrEqual.toString()
            || searchMethod.value === NumberFilterMethod.Between.toString()
            || searchMethod.value === NumberFilterMethod.TopN.toString();
    });

    const firstValuePlaceholder = computed((): string => {
        return searchMethod.value === NumberFilterMethod.Between.toString()
            ? "from"
            : "value";
    });

    const showSecondValue = computed((): boolean => {
        return searchMethod.value === NumberFilterMethod.Between.toString();
    });

    function updateModelValue(): void {
        if (searchValue.value === null && showFirstValue.value) {
            emit("update:modelValue", undefined);
            return;
        }

        const searchBag: NumberSearchBag = {
            method: Number(searchMethod.value) as NumberFilterMethod,
            value: searchValue.value ?? undefined,
            secondValue: secondSearchValue.value ?? undefined
        };

        emit("update:modelValue", searchBag);
    }

    function updateSearchValues(): void {
        if (props.modelValue && typeof props.modelValue === "object") {
            const modelSearchBag = props.modelValue as Partial<NumberSearchBag>;

            if (modelSearchBag.method !== undefined) {
                searchMethod.value = modelSearchBag.method.toString();
                searchValue.value = modelSearchBag.value ?? null;
                secondSearchValue.value = modelSearchBag.secondValue ?? null;

                return;
            }
        }

        searchMethod.value = NumberFilterMethod.Equals.toString();
        searchValue.value = null;
    }

    watch(() => props.modelValue, () => updateSearchValues());
    watch([searchMethod, searchValue, secondSearchValue], () => updateModelValue());

    updateSearchValues();
</script>
