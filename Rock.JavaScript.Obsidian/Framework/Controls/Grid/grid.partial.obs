<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <table class="grid-table table table-bordered table-striped table-hover table-obsidian" :class="{ 'table-sticky': props.stickyHeader }">
        <thead>
            <FilterHeaderRow v-model:filterValue="quickFilterValue"
                                 :gridActions="gridActions"
                                 :visibleColumnCount="visibleColumnCount" />

            <ColumnHeaderRow :columns="visibleColumnDefinitions"
                                 v-model:columnFilters="columnFilterValues"
                                 v-model:columnSort="columnSortDirection"
                                 :rows="rows" />
        </thead>

        <tbody>
            <tr v-if="loadingData">
                <td class="grid-error" :colspan="visibleColumnCount">
                    <LoadingIndicator />
                </td>
            </tr>

            <tr v-else-if="gridErrorMessage">
                <td class="grid-error" :colspan="visibleColumnCount">
                    <Alert alertType="warning">{{ gridErrorMessage }}</Alert>
                </td>
            </tr>

            <DataRows v-else
                          :columns="visibleColumnDefinitions"
                          :rows="visibleRows" />
        </tbody>

        <tfoot>
            <PagerRow v-model:pageSize="pageSize"
                          v-model:currentPage="currentPage"
                          :pageCount="pageCount"
                          :pageSizes="pageSizes"
                          :message="pagerMessage"
                          :visibleColumnCount="visibleColumnCount"
                          :gridActions="gridActions" />
        </tfoot>
    </table>
</template>

<style>
table.table-obsidian.table-sticky > thead {
    position: sticky;
    top: var(--top-header-height);
}

table.table-obsidian th.grid-column-header {
    position: relative;
}

table.table-obsidian th.grid-column-header .btn-grid-column-filter {
    border: 0px;
    background-color: transparent;
    margin-left: 4px;
    color: #e7e7e7;
    opacity: 0.5;
    transition-duration: 250ms;
    transition-property: opacity, color;
}

table.table-obsidian th.grid-column-header .btn-grid-column-filter.active {
    color: var(--brand-success);
}

table.table-obsidian th.grid-column-header:hover .btn-grid-column-filter {
    opacity: 1;
}

table.table-obsidian th.grid-column-header .grid-filter-popup {
    position: absolute;
    display: flex;
    flex-direction: column;
    margin-top: 6px;
    min-width: 240px;
    max-width: 320px;
    max-height: 400px;
    background-color: white;
    border: 1px solid #c7c7c7;
    border-radius: 0px;
    border-bottom-right-radius: 6px;
    border-bottom-left-radius: 6px;
    box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    font-weight: initial;
    z-index: 10;
}

table.table-obsidian th.grid-column-header .grid-filter-popup .grid-filter-popup-content {
    flex-grow: 1;
    overflow-y: auto;
}

table.table-obsidian th.grid-column-header .grid-filter-popup .grid-filter-popup-body {
    margin: 10px;
    padding: 2px;
    overflow-x: clip;
}

table.table-obsidian th.grid-column-header .grid-filter-popup .actions {
    border-top: 1px solid #eee;
    padding: 12px;
}

table.table-obsidian th.grid-column-header .resize-handle {
    position: absolute;
    right: 0px;
    top: 0px;
    bottom: 0px;
    width: 2px;
    height: 100%;
    cursor: w-resize;
}

table.table-obsidian th.grid-column-header:hover .resize-handle {
    background-color: #eee;
}

/* table.table-obsidian td.grid-paging {

} */

table.table-obsidian td.grid-paging .grid-page-sizes {
    flex: 1 0;
    justify-content: start;
    align-items: center;
}

table.table-obsidian td.grid-paging .grid-page-picker {
    flex: 1 0;
    display: flex;
    justify-content: center;
    align-items: center;
}

table.table-obsidian td.grid-paging .grid-page-picker > button {
    border: 0px;
    background-color: transparent;
    margin: 0px 5px;
    padding: 0px 6px;
}

table.table-obsidian td.grid-paging .grid-page-picker > button.disabled {
    opacity: 0.5;
    pointer-events: none;
}

table.table-obsidian td.grid-paging .grid-page-picker > button.active {
    border: 1px solid #b7b7b7;
    background-color: #f7f7f7;
}

table.table-obsidian td.grid-paging .grid-actions {
    flex: 1 0;
    display: flex;
    justify-content: end;
    align-items: center;
}

table.table-obsidian th.grid-filter {
    padding: 8px;
    font-weight: initial;
}

table.table-obsidian th.grid-filter .grid-quick-filter {
    flex: 1 0;
    max-width: 480px;
}

table.table-obsidian th.grid-filter .grid-actions {
    flex: 1 0;
    display: flex;
    justify-content: end;
    background-color: initial;
}

table.table-obsidian th.grid-error {
    padding: 0px;
}

table.table-obsidian th.grid-error > .alert {
    margin-bottom: 0px;
}
</style>

<script setup lang="ts">
    import Alert from "@Obsidian/Controls/alert.obs";
    import LoadingIndicator from "@Obsidian/Controls/loadingIndicator";
    import ColumnHeaderRow from "./columnHeaderRow.partial.obs";
    import DataRows from "./dataRows.partial.obs";
    import FilterHeaderRow from "./filterHeaderRow.partial.obs";
    import PagerRow from "./pagerRow.partial.obs";
    import TextCell from "./Cells/textCell.partial";
    import { computed, defineComponent, PropType, ref, shallowRef, toRaw, useSlots, VNode, watch } from "vue";
    import { resolveMergeFields } from "@Obsidian/Utility/lava";
    import { asFormattedString } from "@Obsidian/Utility/numberUtils";
    import { pluralConditional } from "@Obsidian/Utility/stringUtils";
    import { GridAction, GridColumnDefinition, IGridColumnFilter, IGridData, ValueFormatterFunction } from "@Obsidian/Types/Controls/grid";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { AttributeFieldDefinitionBag } from "@Obsidian/ViewModels/Core/Grid/attributeFieldDefinitionBag";

    type RowCacheItem = {
        quickFilterValue?: string | null;

        sortValue?: string | number | null;

        uniqueValue?: string | number | null;

        filterValue?: unknown | null;
    };

    // const startStamp = Date.now();
    // const mergeF = { row: { name: { firstName: "Daniel", lastName: "Hazelbaker" }}};
    // for (let i = 0; i < 10000; i++) {
    //     resolveMergeFields("{{ row.name.firstName }} {{ row.name.lastName }}", mergeF);
    // }
    // const endStamp = Date.now();
    // console.log(`Test took ${endStamp - startStamp}ms.`);

    function getVNodeProp<T>(node: VNode, propName: string): T | undefined {
        if (node.props && node.props[propName] !== undefined) {
            return node.props[propName] as T;
        }

        if (typeof node.type === "object" && typeof node.type["props"] === "object") {
            const defaultProps = node.type["props"] as Record<string, unknown>;
            const defaultProp = defaultProps[propName];
            if (defaultProp && typeof defaultProp === "object" && defaultProp["default"] !== undefined) {
                return defaultProp["default"] as T;
            }
        }

        return undefined;
    }

    function getVNodeProps(node: VNode): Record<string, unknown> {
        const props: Record<string, unknown> = {};

        // Get all default values.
        if (typeof node.type === "object" && typeof node.type["props"] === "object") {
            const defaultProps = node.type["props"] as Record<string, unknown>;

            for (const p in defaultProps) {
                const defaultProp = defaultProps[p];

                if (defaultProp && typeof defaultProp === "object" && defaultProp["default"] !== undefined) {
                    props[p] = defaultProp["default"];
                }
            }
        }

        // Get specified values.
        if (node.props) {
            for (const p in node.props) {
                props[p] = node.props[p];
            }
        }

        return props;
    }

    function resolveDynamicText(text: string, mergeFields: Record<string, unknown>): string {
        return resolveMergeFields(text, mergeFields);
    }

    function getOrUpdateQuickFilterValueCache(row: Record<string, unknown>, column: GridColumnDefinition, factory: ((row: Record<string, unknown>, column: GridColumnDefinition) => string | undefined)): string | undefined {
        if (props.itemId === undefined) {
            return factory(row, column);
        }

        const rowId = row[props.itemId];

        if (typeof rowId !== "string" && typeof rowId !== "number") {
            return factory(row, column);
        }

        const cacheKey = `row-item-${rowId}`;
        let cache = gridData.cache[cacheKey] as RowCacheItem | undefined;

        if (!cache) {
            cache = {
                quickFilterValue: null,
                sortValue: null,
                uniqueValue: null,
                filterValue: null
            };
            gridData.cache[cacheKey] = cache;
        }

        if (cache.quickFilterValue === null) {
            cache.quickFilterValue = factory(row, column);
        }

        return cache.quickFilterValue;
    }

    function getColumnDefinitions(columnNodes: VNode[]): GridColumnDefinition[] {
        const columns: GridColumnDefinition[] = [];

        for (const node of columnNodes) {
            const name = getVNodeProp<string>(node, "name");

            if (!name) {
                if (getVNodeProp<boolean>(node, "__attributeColumns") !== true) {
                    continue;
                }

                const attributes = getVNodeProp<AttributeFieldDefinitionBag[]>(node, "attributes");
                if (!attributes) {
                    continue;
                }

                for (const attribute of attributes) {
                    if (!attribute.name) {
                        continue;
                    }

                    columns.push({
                        name: attribute.name,
                        title: attribute.title ?? undefined,
                        field: attribute.name,
                        uniqueValue: (r, c) => c.field ? String(r[c.field]) : "",
                        sortValue: (r, c) => c.field ? String(r[c.field]) : undefined,
                        quickFilterValue: (r, c) => getOrUpdateQuickFilterValueCache(r, c, () => c.field ? String(r[c.field]) : undefined),
                        filterValue: (r, c) => c.field ? String(r[c.field]) : undefined,
                        format: getVNodeProp<VNode>(node, "format") ?? TextCell,
                        props: {}
                    });
                }

                continue;
            }

            const field = getVNodeProp<string>(node, "field");
            let sortValue = getVNodeProp<ValueFormatterFunction | string>(node, "sortValue");

            if (!sortValue) {
                const sortField = getVNodeProp<string>(node, "sortField") || field;

                sortValue = sortField ? (r) => String(r[sortField]) : undefined;
            }
            else if (typeof sortValue === "string") {
                const template = sortValue;

                sortValue = (row): string | undefined => {
                    return resolveDynamicText(template, { row });
                };
            }

            let quickFilterValue = getVNodeProp<((row: Record<string, unknown>, column: GridColumnDefinition) => string | undefined)>(node, "quickFilterValue");

            if (!quickFilterValue) {
                quickFilterValue = (r, c): string | undefined => {
                    if (!c.field) {
                        return undefined;
                    }

                    let v = r[c.field];

                    if (typeof v === "string") {
                        return v;
                    }
                    else if (typeof v === "number") {
                        return v.toString();
                    }


                    else {
                        return undefined;
                    }
                };
            }
            else if (typeof quickFilterValue === "string") {
                const template = quickFilterValue;

                quickFilterValue = (row): string | undefined => {
                    return resolveDynamicText(template, { row });
                };
            }

            let filterValue = getVNodeProp<((row: Record<string, unknown>, column: GridColumnDefinition) => unknown) | string>(node, "filterValue");

            if (filterValue === undefined) {
                filterValue = (r, c): unknown => {
                    if (!c.field) {
                        return undefined;
                    }

                    return r[c.field];
                };
            }
            else if (typeof filterValue === "string") {
                const template = filterValue;

                filterValue = (row): string | undefined => {
                    return resolveDynamicText(template, { row });
                };
            }

            let uniqueValue = getVNodeProp<ValueFormatterFunction>(node, "uniqueValue");

            if (!uniqueValue) {
                uniqueValue = (r, c) => {
                    if (!c.field || r[c.field] === undefined) {
                        return undefined;
                    }

                    const v = r[c.field];

                    if (typeof v === "string" || typeof v === "number") {
                        return v;
                    }

                    return JSON.stringify(v);
                };
            }

            columns.push({
                name,
                title: getVNodeProp<string>(node, "title"),
                field,
                format: node.children?.["body"] ?? getVNodeProp<VNode>(node, "format") ?? TextCell,
                filter: getVNodeProp<IGridColumnFilter>(node, "filter"),
                uniqueValue,
                sortValue,
                filterValue,
                quickFilterValue: (r, c) => quickFilterValue !== undefined ? getOrUpdateQuickFilterValueCache(r, c, quickFilterValue) : undefined,
                props: getVNodeProps(node)
            });
        }

        return columns;
    }

    /*
     * 8/17/2022 - DSH
     *
     * The grid uses a number of non-ref instances with calculations via function call.
     * This is because the normal wrapped references that Vue uses dramatically slow
     * down our filtering and sorting processes. For example, filtering over wrapped
     * references of 100,000 rows takes around 600ms. The same 100,000 rows using an
     * unwrapped raw array takes about 40ms.
     */

    const props = defineProps({
        data: {
            type: [Object, Function] as PropType<GridDataBag | (() => GridDataBag | Promise<GridDataBag>)>,
            default: []
        },

        itemId: {
            type: String as PropType<string>,
            required: false
        },

        /** If enabled then the grid will have a sticky header. */
        stickyHeader: {
            type: Boolean as PropType<boolean>,
            default: false
        }
    });

    function doTest(): void {
        console.log("test");
    }

    defineExpose({doTest});

    const slots = useSlots();

    const gridData: IGridData = {
        cache: {},

        rows: []
    };

    const gridActions = ref<GridAction[]>([]);
    const currentPage = ref(1);
    const pageSize = ref(50);
    const pageSizes = [50, 500, 5000];
    const quickFilterValue = ref("");
    const loadingData = ref(false);
    const gridErrorMessage = ref("");
    const columnFilterValues = ref<Record<string, unknown | undefined>>({});
    const columnSortDirection = ref<{ column: string, isDescending: boolean } | undefined>();
    const visibleRows = shallowRef<Record<string, unknown>[]>([]);
    const pageCount = ref(0);
    const pagerMessage = ref("");
    const visibleColumnDefinitions = ref<GridColumnDefinition[]>([]);
    const rows = shallowRef<Record<string, unknown>[]>([]);
    const columns = computed((): GridColumnDefinition[] => {
        return getColumnDefinitions(slots["default"]?.() ?? []);
    });

    let filteredRows: Record<string, unknown>[] = [];
    let sortedRows: Record<string, unknown>[] = [];

    const visibleColumnCount = computed((): number => {
        return visibleColumnDefinitions.value.length;
    });

    function updateFilteredRows(): void {
        const start = Date.now();
        if (columns.value.length > 0) {
            const columns = toRaw(visibleColumnDefinitions.value);
            const quickFilterRawValue = quickFilterValue.value.toLowerCase();

            const result = rows.value.filter(row => {
                const quickFilterMatch = !quickFilterRawValue || columns.some((column): boolean => {
                    const value = column.quickFilterValue(row, column);

                    if (value === undefined) {
                        return false;
                    }

                    return value.toLowerCase().includes(quickFilterRawValue);
                });

                const filtersMatch = columns.every(column => {
                    if (!column.filter) {
                        return true;
                    }

                    const columnFilterValue = columnFilterValues.value[column.name];

                    if (columnFilterValue === undefined) {
                        return true;
                    }

                    const value: unknown = column.filterValue(row, column);

                    if (value === undefined) {
                        return false;
                    }

                    return column.filter.matches(columnFilterValue, value, column, gridData);
                });

                return quickFilterMatch && filtersMatch;
            });

            filteredRows = result;
        }
        else {
            filteredRows = [];
        }
        console.log(`Filtering took ${Date.now() - start}ms.`);

        updateSortedRows();
        updatePageCount();
        updatePagerMessage();
    }

    function updateSortedRows(): void {
        const sortDirection = columnSortDirection.value;

        if (!sortDirection) {
            sortedRows = filteredRows;
            updateVisibleRows();

            return;
        }

        const start = Date.now();
        const column = visibleColumnDefinitions.value.find(c => c.name === sortDirection.column);
        const order = sortDirection.isDescending ? -1 : 1;

        if (!column) {
            throw new Error("Invalid sort definition");
        }

        const sortValue = column.sortValue;

        // Pre-process each row to calculate the sort value. Otherwise it will
        // be calculated exponentially during sort. This provides a serious
        // performance boost when sorting Lava columns.
        const rows = filteredRows.map(r => {
            let value: string | number | undefined;

            if (sortValue) {
                value = sortValue(r, column);
            }
            else {
                value = undefined;
            }

            return {
                row: r,
                value
            };
        });

        rows.sort((a, b) => {
            if (a.value === undefined) {
                return -order;
            }
            else if (b.value === undefined) {
                return order;
            }
            else if (a.value < b.value) {
                return -order;
            }
            else if (a.value > b.value) {
                return order;
            }
            else {
                return 0;
            }
        });

        sortedRows = rows.map(r => r.row);

        console.log(`sortedRows took ${Date.now() - start}ms.`);
        updateVisibleRows();
    }

    function updateVisibleRows(): void {
        const startIndex = (currentPage.value - 1) * pageSize.value;

        visibleRows.value = sortedRows.slice(startIndex, startIndex + pageSize.value);
    }

    function updatePageCount(): void {
        pageCount.value = Math.ceil(filteredRows.length / pageSize.value);
    }

    function updatePagerMessage(): void {
        pagerMessage.value = `${asFormattedString(filteredRows.length)} ${pluralConditional(filteredRows.length, "Group", "Groups")}`;
    }

    async function updateGridData(): Promise<void> {
        loadingData.value = true;

        if (typeof props.data === "object") {
            const data = props.data;
            rows.value = data.rows ?? [];
        }
        else if (typeof props.data === "function") {
            try {
                const data = await props.data();
                rows.value = data.rows ?? [];

                gridData.rows = data.rows ?? [];
                gridData.cache = {};
            }
            catch (error) {
                gridErrorMessage.value = error instanceof Error ? error.message : new String(error).toString();
            }
        }

        visibleColumnDefinitions.value = columns.value;
        updateFilteredRows();

        loadingData.value = false;
    }

    function onActionClick(): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, 2000));
    }

    watch([quickFilterValue, columnFilterValues], () => {
        currentPage.value = 1;
        updateFilteredRows();
    });

    watch(columnSortDirection, () => {
        updateSortedRows();
    });

    watch([currentPage, pageSize], () => {
        updateVisibleRows();
    });

    gridActions.value.push({
        executing: false,
        handler: onActionClick,
        iconCssClass: "fa fa-question",
        tooltip: "This gives you help."
    });

    gridActions.value.push({
        executing: false,
        handler: onActionClick,
        iconCssClass: "fa fa-plus",
        tooltip: "Add a new item."
    });

    updateGridData();
</script>
