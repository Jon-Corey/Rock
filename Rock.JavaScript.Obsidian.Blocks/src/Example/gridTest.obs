<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Grid ref="myGrid" :data="loadGridData" itemId="guid" stickyHeader>
        <Column name="name" title="Name" sortValue="{{ row.name.lastName }} {{ row.name.firstName }}" :filter="textColumnFilter" quickFilterValue="{{ row.name.firstName }} {{  row.name.lastName }}">
            <template #body="{ row }">
                {{ row.name.firstName }} {{ row.name.lastName }}
            </template>
        </Column>

        <Column name="email" title="Email" field="email" sortField="email" :filter="pickExistingColumnFilter" />

        <Column name="enteredDateTime" title="Entered On" field="enteredDateTime" sortField="enteredDateTime">
            <template #body="{ row }">
                {{ formatDate(row.enteredDateTime) }}
            </template>
        </Column>

        <NumberColumn name="id" title="Id" field="id" sortField="id" :filter="numberColumnFilter" />

        <DateColumn name="expirationDateTime" title="Expires" field="expirationDateTime" sortField="expirationDateTime" />

        <BooleanColumn name="isUrgent" title="Urgent" field="isUrgent" sortField="isUrgent" />

    <!--
        <BadgeColumn name="isUrgent"
                          title="Urgent"
                          field="isUrgent"
                          sortField="isUrgent"
                          :classSource="badgeClassLookup" />
    -->

    <!--
        <Column name="isUrgent"
                title="Urgent"
                field="isUrgent"
                sortField="isUrgent">
            <template #body="{ row }">
                <span v-if="row.isUrgent"
                      class="label label-success">
                    {{ row.isUrgent }}
                </span>
                <span v-else
                      class="label label-danger">
                    {{ row.isUrgent }}
                </span>
            </template>
        </Column>
    -->

        <ColoredBadgeColumn name="mode"
                            title="Mode"
                            field="mode"
                            :filter="pickExistingColumnFilter"
                            quickFilterValue="{{ row.mode.text }}" />

        <BooleanColumn name="isPublic"
                       title="Public"
                       field="isPublic"
                       sortField="isPublic" />

        <AttributeColumns :attributes="attributeFields" />
    </Grid>
</template>

<script setup lang="ts">
    // #region Imports
    import TextBox from "@Obsidian/Controls/textBox";
    import { useConfigurationValues, useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { Component, computed, defineComponent, PropType, ref, VNode, watch } from "vue";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { GridDefinitionBag } from "@Obsidian/ViewModels/Core/Grid/gridDefinitionBag";
    import { AttributeFieldDefinitionBag } from "@Obsidian/ViewModels/Core/Grid/attributeFieldDefinitionBag";
    import Grid, { NumberColumnFilter, PickExistingColumnFilter } from "@Obsidian/Controls/grid";
    import { FilterComponentProps, GridColumnDefinition, IGridColumnFilter, IGridData } from "@Obsidian/Types/Controls/grid";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { NumberFilterMethod } from "@Obsidian/Enums/Controls/Grid/numberFilterMethod";

    // Putting this here as an example of how to call methods on components.
    // Such as myGrid.value.reloadItem(item.id);
    const myGrid = ref<InstanceType<typeof Grid> | null>();
    setTimeout(() => {
        if (!myGrid.value) {
            return;
        }
        myGrid.value.doTest();
    }, 1000);

    const standardColumnProps = {
        name: {
            type: String as PropType<string>,
            default: ""
        },

        title: {
            type: String as PropType<string>,
            required: false
        },

        textValue: {
            type: Object as PropType<(((row: Record<string, unknown>, column: GridColumnDefinition) => string | number | undefined) | string)>,
            required: false
        },

        sortField: {
            type: String as PropType<string>,
            required: false
        },

        sortValue: {
            type: Object as PropType<(((row: Record<string, unknown>, column: GridColumnDefinition) => string | number | undefined) | string)>,
            required: false
        },

        filter: {
            type: Object as PropType<IGridColumnFilter>,
            required: false
        },

        filterValue: {
            type: Object as PropType<(((row: Record<string, unknown>, column: GridColumnDefinition) => string | number | undefined) | string)>,
            required: false
        }
    };

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const Column = defineComponent({
        props: {
            ...standardColumnProps
        }
    });

    const dateColumnValueComponent = defineComponent({
        props: {
            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },
            row: {
                type: Object as PropType<Record<string, unknown>>,
                required: true
            }
        },

        setup(props) {
            const formattedValue = computed(() => {
                if (props.column.field) {
                    return RockDateTime.parseISO(props.row[props.column.field] as string)?.toASPString("d") ?? "";
                }
                else {
                    return "";
                }
            });

            return {
                formattedValue
            };
        },

        template: `{{ formattedValue }}`
    });

    // eslint-disable-next-line @typescript-eslint/naming-convention
    const DateColumn = defineComponent({
        props: {
            ...standardColumnProps,

            format: {
                type: Object as PropType<VNode>,
                required: false,
                default: dateColumnValueComponent
            },

            quickFilterValue: {
                type: Object as PropType<((row: Record<string, unknown>, column: GridColumnDefinition) => string | undefined)>,
                default: (r: Record<string, unknown>, c: GridColumnDefinition) => {
                    if (!c.field) {
                        return undefined;
                    }

                    return RockDateTime.parseISO(r[c.field] as string)?.toASPString("d");
                }
            }
        }
    });

    const booleanColumnValueComponent = defineComponent({
        props: {
            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },
            row: {
                type: Object as PropType<Record<string, unknown>>,
                required: true
            }
        },

        setup(props) {
            const isTrue = computed(() => {
                if (props.column.field) {
                    return props.row[props.column.field] === true;
                }
                else {
                    return false;
                }
            });

            return {
                isTrue
            };
        },

        template: `<i v-if="isTrue" class="fa fa-check"></i>`
    });

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const BooleanColumn = defineComponent({
        props: {
            ...standardColumnProps,

            format: {
                type: Object as PropType<VNode>,
                required: false,
                default: booleanColumnValueComponent
            }
        }
    });

    const numberColumnValueComponent = defineComponent({
        props: {
            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },
            row: {
                type: Object as PropType<Record<string, unknown>>,
                required: true
            }
        },

        setup(props) {
            const formattedValue = computed((): string => {
                if (!props.column.field) {
                    return "";
                }

                const value = props.row[props.column.field];

                if (typeof value !== "number") {
                    return "";
                }

                return value.toLocaleString();
            });

            return {
                formattedValue
            };
        },

        template: `{{ formattedValue }}`
    });

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const NumberColumn = defineComponent({
        props: {
            ...standardColumnProps,

            format: {
                type: Object as PropType<VNode>,
                required: false,
                default: numberColumnValueComponent
            }
        }
    });

    const badgeColumnValueComponent = defineComponent({
        props: {
            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },

            row: {
                type: Object as PropType<Record<string, unknown>>,
                required: true
            }
        },

        setup(props) {
            const text = computed(() => {
                if (props.column.field) {
                    return `${props.row[props.column.field]}`;
                }
                else {
                    return "";
                }
            });

            const labelClass = computed(() => {
                const classSource = props.column.props["classSource"] as Record<string, string>;

                if (classSource && text.value in classSource) {
                    return `label label-${classSource[text.value]}`;
                }
                else {
                    return "label label-default";
                }
            });

            return {
                text,
                labelClass
            };
        },

        template: `<span :class="labelClass">{{ text }}</span>`
    });

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const BadgeColumn = defineComponent({
        props: {
            ...standardColumnProps,

            format: {
                type: Object as PropType<VNode>,
                required: false,
                default: badgeColumnValueComponent
            },

            classSource: {
                type: Object as PropType<Record<string, string>>,
                required: false
            }
        }
    });

    const badgeColorColumnValueComponent = defineComponent({
        props: {
            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },

            row: {
                type: Object as PropType<Record<string, unknown>>,
                required: true
            }
        },

        setup(props) {
            const text = computed(() => {
                if (props.column.field) {
                    return `${props.row[props.column.field]}`;
                }
                else {
                    return "";
                }
            });

            const labelStyle = computed(() => {
                const colorSource = props.column.props["colorSource"] as Record<string, string>;

                if (colorSource && text.value in colorSource) {
                    return {
                        "backgroundColor": colorSource[text.value],
                        "color": "white"
                    };
                }
                else {
                    return {
                        "backgroundColor": "gray",
                        "color": "white"
                    };
                }
            });

            return {
                text,
                labelStyle
            };
        },

        template: `<span class="label label-default" :style="labelStyle">{{ text }}</span>`
    });

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const BadgeColorColumn = defineComponent({
        props: {
            ...standardColumnProps,

            format: {
                type: Object as PropType<VNode>,
                required: false,
                default: badgeColorColumnValueComponent
            },

            colorSource: {
                type: Object as PropType<Record<string, string>>,
                required: false
            }
        }
    });

    const coloredBadgeColumnValueComponent = defineComponent({
        props: {
            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },

            row: {
                type: Object as PropType<Record<string, unknown>>,
                required: true
            }
        },

        setup(props) {
            const text = computed(() => {
                if (props.column.field) {
                    return `${(props.row[props.column.field] as ListItemBag).text}`;
                }
                else {
                    return "";
                }
            });

            const labelStyle = computed(() => {
                if (props.column.field && props.row[props.column.field] && (props.row[props.column.field] as ListItemBag).value) {
                    return {
                        "backgroundColor": (props.row[props.column.field] as ListItemBag).value,
                        "color": "white"
                    };
                }
                else {
                    return {
                        "backgroundColor": "gray",
                        "color": "white"
                    };
                }
            });

            return {
                text,
                labelStyle
            };
        },

        template: `<span class="label label-default" :style="labelStyle">{{ text }}</span>`
    });

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const ColoredBadgeColumn = defineComponent({
        props: {
            ...standardColumnProps,

            format: {
                type: Object as PropType<VNode>,
                default: coloredBadgeColumnValueComponent
            }
        }
    });

    function textColumnFilterValue(needle: unknown, haystack: unknown): boolean {
        if (typeof (needle) !== "string") {
            return false;
        }

        if (!needle) {
            return true;
        }

        const lowerNeedle = needle.toLowerCase();

        if (haystack && typeof (haystack) === "string") {
            return haystack.toLowerCase().includes(lowerNeedle);
        }

        return false;
    }

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const TextColumnFilterComponent: Component<FilterComponentProps> = defineComponent({
        props: {
            modelValue: {
                type: Object as PropType<unknown>,
                required: false
            },

            column: {
                type: Object as PropType<GridColumnDefinition>,
                required: true
            },

            rows: {
                type: Array as PropType<Record<string, unknown>[]>,
                required: true
            }
        },

        components: {
            TextBox
        },

        setup(props, { emit }) {
            const internalValue = ref(typeof (props.modelValue) === "string" ? props.modelValue : "");

            watch(() => props.modelValue, () => {
                internalValue.value = typeof (props.modelValue) === "string" ? props.modelValue : "";
            });

            watch(internalValue, () => {
                emit("update:modelValue", internalValue.value);
            });

            return {
                internalValue
            };
        },

        template: `
        <TextBox v-model="internalValue" />
        `
    });

    const textColumnFilter: IGridColumnFilter = {
        component: TextColumnFilterComponent,

        matches: textColumnFilterValue
    };

    function pickExistingColumnFilterValue(needle: unknown, haystack: unknown): boolean {
        if (!Array.isArray(needle)) {
            return false;
        }

        if (needle.length === 0) {
            return true;
        }

        return needle.some(n => deepEqual(n, haystack, true));
    }

    const pickExistingColumnFilter: IGridColumnFilter = {
        component: PickExistingColumnFilter,

        matches: pickExistingColumnFilterValue
    };

    function calculateColumnAverage(rows: Record<string, unknown>[], column: GridColumnDefinition): number {
        let count = 0;
        let total = 0;
        for (const row of rows) {
            const rowValue = column.filterValue(row, column);

            if (typeof rowValue === "number") {
                total += rowValue;
                count++;
            }
        }

        return count === 0 ? 0 : total / count;
    }

    function calculateColumnTopNRowValue(rows: Record<string, unknown>[], rowCount: number, column: GridColumnDefinition): number {
        const values: number[] = [];

        for (const row of rows) {
            const rowValue = column.filterValue(row, column);

            if (typeof rowValue === "number") {
                values.push(rowValue);
            }
        }

        // Sort in descending order.
        values.sort((a, b) => b - a);

        if (rowCount <= values.length) {
            return values[rowCount - 1];
        }
        else {
            return values[values.length - 1];
        }
    }

    function numberColumnFilterValue(needle: unknown, haystack: unknown, column: GridColumnDefinition, gridData: IGridData): boolean {
        if (!needle || typeof needle !== "object") {
            return false;
        }

        // Allow undefined values and number values, but everything else is
        // considered a non-match.
        if (haystack !== undefined && typeof haystack !== "number") {
            return false;
        }

        if (needle["method"] === NumberFilterMethod.Equals) {
            return haystack === needle["value"];
        }
        else if (needle["method"] === NumberFilterMethod.DoesNotEqual) {
            return haystack !== needle["value"];
        }

        // All the remaining comparison types require a value.
        if (haystack === undefined) {
            return false;
        }

        if (needle["method"] === NumberFilterMethod.GreaterThan) {
            return haystack > needle["value"];
        }
        else if (needle["method"] === NumberFilterMethod.GreaterThanOrEqual) {
            return haystack >= needle["value"];
        }
        else if (needle["method"] === NumberFilterMethod.LessThan) {
            return haystack < needle["value"];
        }
        else if (needle["method"] === NumberFilterMethod.LessThanOrEqual) {
            return haystack <= needle["value"];
        }
        else if (needle["method"] === NumberFilterMethod.Between) {
            if (typeof needle["value"] !== "number" || typeof needle["secondValue"] !== "number") {
                return false;
            }

            return haystack >= needle["value"] && haystack <= needle["secondValue"];
        }
        else if (needle["method"] === NumberFilterMethod.TopN) {
            const nCount = needle["value"];

            if (typeof nCount !== "number" || nCount <= 0) {
                return false;
            }

            const cacheKey = `number-filter-${column.name}.top-${nCount}`;
            let topn = gridData.cache[cacheKey] as number | undefined;

            if (topn === undefined) {
                topn = calculateColumnTopNRowValue(gridData.rows, nCount, column);
                gridData.cache[cacheKey] = topn;
            }

            return haystack >= topn;
        }
        else if (needle["method"] === NumberFilterMethod.AboveAverage) {
            const cacheKey = `number-filter-${column.name}.average`;
            let average = gridData.cache[cacheKey] as number | undefined;

            if (average === undefined) {
                average = calculateColumnAverage(gridData.rows, column);
                gridData.cache[cacheKey] = average;
            }

            return haystack > average;
        }
        else if (needle["method"] === NumberFilterMethod.BelowAverage) {
            const cacheKey = `number-filter-${column.name}.average`;
            let average = gridData.cache[cacheKey] as number | undefined;

            if (average === undefined) {
                average = calculateColumnAverage(gridData.rows, column);
                gridData.cache[cacheKey] = average;
            }

            return haystack < average;
        }
        else {
            return false;
        }
    }

    const numberColumnFilter: IGridColumnFilter = {
        component: NumberColumnFilter,

        matches: numberColumnFilterValue
    };

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const AttributeColumns = defineComponent({
        components: {
            Column
        },

        props: {
            attributes: {
                type: Array as PropType<AttributeFieldDefinitionBag[]>,
                default: []
            },

            __attributeColumns: {
                type: Boolean as PropType<boolean>,
                default: true
            }
        }
    });

    // #endregion

    const configuration = useConfigurationValues<{ gridDefinition: GridDefinitionBag }>();
    const invokeBlockAction = useInvokeBlockAction();

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const badgeClassLookup = {
        "true": "success",
        "false": "danger"
    };

    // eslint-disable-next-line @typescript-eslint/naming-convention,@typescript-eslint/no-unused-vars
    const badgeColorLookup = {
        "true": "#00cc00",
        "false": "#cc0000"
    };

    const attributeFields = computed((): AttributeFieldDefinitionBag[] => {
        return configuration.gridDefinition.attributeFields ?? [];
    });

    const loadGridData = async (): Promise<GridDataBag> => {
        const result = await invokeBlockAction<GridDataBag>("GetGridData");

        if (result.isSuccess && result.data) {
            const d = ref(result.data.rows ?? []);
            setTimeout(() => (d.value[0] as Record<string, Record<string, string>>)["name"]["firstName"] = "Daniel", 2000);
            return {
                rows: d.value
            };
        }
        else {
            throw new Error(result.errorMessage ?? "Unknown error while trying to load grid data.");
        }
    };

    function formatDate(value?: string): string {
        if (!value) {
            return "";
        }

        const dt = RockDateTime.parseISO(value);

        return dt?.toASPString("g") ?? "";
    }
</script>
