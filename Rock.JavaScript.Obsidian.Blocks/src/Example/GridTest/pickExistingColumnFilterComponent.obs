<template>
    <div class="grid-filter-popup-body">
        <TextBox label="Search"
                 v-model="searchValue" />
        <div v-for="value in displayedValues" class="d-flex align-items-center mb-2">
            <label class="checkbox-inline">
                <input type="checkbox" :checked="value.selected" @change="onSelected(value, $event)" />
                <span class="label-text">&nbsp;</span>
            </label>
            <component :is="column.format" :row="value.row" :column="column" />
        </div>
    </div>
</template>

<script setup lang="ts">
    import TextBox from "@Obsidian/Controls/textBox";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { ref, PropType, watch, computed } from "vue";
    import { GridColumnDefinition } from "./types";

    const props = defineProps({
        modelValue: {
            type: Object as PropType<unknown>,
            required: false
        },

        column: {
            type: Object as PropType<GridColumnDefinition>,
            required: true
        },

        rows: {
            type: Array as PropType<Record<string, unknown>[]>,
            required: true
        }
    });

    const emit = defineEmits<{
        (event: "update:modelValue", value: unknown): void
    }>();

    type DistinctValue = {
        row: Record<string, unknown>;

        sortValue?: string | number;

        quickFilterValue: string;

        filterValue: unknown;

        selected: boolean
    };

    const distinctValues = ref<DistinctValue[]>([]);
    const searchValue = ref("");

    const displayedValues = computed((): DistinctValue[] => {
        let values = distinctValues.value;

        if (searchValue.value) {
            const lowerSearchValue = searchValue.value.toLowerCase();

            values = values.filter(v => v.quickFilterValue.includes(lowerSearchValue));
        }

        console.log(values.slice(0, 50));

        return values.slice(0, 50);
    });

    function getDistinctValues(): DistinctValue[] {
        const valueRows: Record<string | number, DistinctValue> = {};
        const field = props.column.field;

        if (!field) {
            return [];
        }

        console.log(`${Date.now()}: Starting Process`);
        for (let i = 0; i < props.rows.length; i++) {
            const value = props.column.uniqueValue(props.rows[i], props.column);

            if (value && valueRows[value] === undefined) {
                const quickFilterValue = props.column.quickFilterValue(props.rows[i], props.column) ?? "";
                let filterValue = props.column.filterValue(props.rows[i], props.column);

                if (filterValue === undefined) {
                    continue;
                }

                valueRows[value] = {
                    row: props.rows[i],
                    selected: false,
                    sortValue: props.column.sortValue?.(props.rows[i], props.column) ?? "",
                    quickFilterValue: quickFilterValue.toLowerCase(),
                    filterValue
                };
            }
        }
        console.log(`${Date.now()}: Finished Process, ${Object.values(valueRows).length} unique values out of ${props.rows.length} rows.`);

        return Object.values(valueRows);
    }

    function onSelected(value: DistinctValue, event: Event): void {
        const selected = (event.target as HTMLInputElement).checked;

        if (value.selected !== selected) {
            value.selected = selected;

            updateModelValue();
        }
    }

    function updateModelValue(): void {
        const values: unknown[] = [];

        if (props.column.field) {
            for (const value of distinctValues.value) {
                if (value.selected) {
                    values.push(props.column.filterValue(value.row, props.column));
                }
            }
        }

        emit("update:modelValue", values.length > 0 ? values : undefined);
    }

    function updateSelectedValues(): void {
        if (!props.modelValue || !Array.isArray(props.modelValue) || !props.column.field) {
            for (const value of distinctValues.value) {
                value.selected = false;
            }

            return;
        }

        for (const value of distinctValues.value) {
            value.selected = props.modelValue.some(mv => deepEqual(mv, value.filterValue, true));
        }
    }

    watch(() => props.rows, () => {
        distinctValues.value = getDistinctValues();
    });

    watch(() => props.modelValue, () => updateSelectedValues());

    distinctValues.value = getDistinctValues();
    updateSelectedValues();
</script>
